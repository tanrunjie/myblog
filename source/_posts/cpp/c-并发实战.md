---
title: c++并发实战
mathjax: true
date: 2021-12-28 10:48:17
tags: c++ 多线程 并发
categories:
- c++
---

### chap1 c++并发世界
C++98的13年后，2011的C++11成为新的规范，同时确认了每三年发布新的扩展技术规范。
在C++11中，c++ standard第一次承认多线程存在于C++语言中，意味CPP编写与平台无关的多线程程序成为可能。以往编写多线程并发需要针对运行平台部署依赖扩展库，如今可移植性成为可能。

`何谓并发和多线程？`  
单核的并发存在切换上下文的不必要损耗。
多线程：一个进程下，多个小单元共用数据资源，单机并发较常用，实际上CPP支持的是多线程。
多进程：开辟多个共用数据资源，多个进程并行，占用大量资源，通讯成本加大，适用于多机。

并行：关注性能； 并发：关注任务分离；

`为什么要并发?`  
1. 关注分离：将相关代码与无关代码分离，使得程序更容易理解和测试。
2. 关注性能：将任务并行以及可以将数据并行
不使用并发的原因：收益比不上成本，一方面脑力以及代码维护成本，一方面是线程资源。尤其32位地址的架构，
对于4G(32bit)的架构，每个线程占用1MB，那么开4096个就用尽所有地址，运行太多会出问题。对于现用的板子有1GB的内存可用。对于现用的64位PC，开一个线程ulimit -s可知为8MB;ulimit -u可以看当前可开多少个线程上限，64GB可开约26万个上限。
由于多线程使代码复杂且难以理解，只有显著提升性能才值得一干。

### chap2 线程管理
- 线程启动：std::thread对象用函数或者类初始化的同时，开始自动启动线程。
- 线程等待与分离：join为等待线程执行完成；detach则让线程分离自主执行，此时访问已销毁的变量会引起错误。如果线程已使用过join,则不可再次join。joinable()返回false。
解决方法：将数据复制到线程中，可以总结用一个访问局部变量的函数创建线程是危险行为。
- 分离线程：通常又称守护线程，没有任何显式的用户接口并在后台运行的线程，通常长时间运行。
- 转移线程： thread2 = std::move(thread1);若thread2已有线程，则系统直接调用terminate结束错误。

